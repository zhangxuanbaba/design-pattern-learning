装饰模式(decorator)

一、定义
动态地给一个对象增加一些额外的职责，就增加对象功能来说，装饰模式远比生成子类实现更加灵活。装饰模式是一种对象结构型模式。　

二、结构
Component （抽象构件）：具体构件和抽象装饰类的基类，声明了在具体构建中实现的业务方法。
ConcreteComponent（具体构件）：抽象构件的子类，用于定义具体的构件对象，实现了在抽象构件中声明的方法，装饰器可以给它增加额外的职责（方法）。
Decorator（抽象装饰类）：它也是抽象构件类的子类，用于给具体构件增加职责，但是具体职责在其子类中实现。
ConcreteDecorator（具体装饰类）：抽象装饰类的子类，负责向构件添加新的职责。

三、优点
对于扩展一个对象的功能，装饰模式比继承更加灵活，不会导致类的个数急剧增加！
可以对一个对象进行多次装饰，从而创造出很多不同行为的组合，得到功能更为强大的对象！
具体构件类与具体装饰类可以独立变化，可以根据需要增加新的具体构建和具体装饰，原有代码无需修改，符合开放封闭原则！

四、缺点
虽然装饰模式拱了一种比继承更加灵活机动的方案，但同时也意味着比继承更加易于出错，排错也很困难。
特别是经过多次装饰的对象，调试时寻找错误可能需要逐级排查，较为繁琐。

五、应用场景
在不影响其他对象的情况下，想要动态地、透明地给单个对象添加职责
当不能采用继承的方式对系统进行扩展 或 采取继承不利于系统扩展和维护时

六、个人总结
1、通过购买奶茶的例子来理解装饰模式，顾客买一杯奶茶，你需要给出对这个奶茶的描述和价格。
    如果不使用装饰模式，那么我们会设计一个奶茶的父类，带有基本的描述和最基本奶茶的价格。
    其他种类的奶茶，如珍珠奶茶则会继承自这个父类，然后重写父类的方法，添加自己的描述和价格。
        遇到的问题：
            * 1、如果出一个新的奶茶品种，就需要新加入一个类，那么如果有100种奶茶就有100个类
            * 2、如果需要加双份的椰果奶茶，怎么办？如果需要无糖奶茶的呢？
            * 3、如果价格要临时变动怎么办？
    如果使用装饰模式，那么我们可以动态的给单个对象多次的装饰，组成不同的样子的同一种对象
        比如你需要珍珠奶茶，就用珍珠去装饰奶茶；你需要双份椰果奶茶，就用椰果装饰两次。

2、对于Component（抽象构件）来说，它是被装饰的基本单位，而ConcreteComponent（具体构件）则是它不同的表现形式
    同样的，Decorator（抽象装饰）是最基本的装饰单位，它要求每个具体装饰类都必须做的事情，如这里的说明。
    具体来说，在使用的时候，对于一个对象来说对于有本质上面区别的，使用不同的具体构建；
    而只是对其进行装饰（修饰）的，使用不同的具体装饰。
    还有一个重要区别是，构件只能被构建一次，也就直接决定了对象的主要性质，而装饰可以进行多次。
